# 数据库微服务拆分对比报告

## 一、拆分前架构（单体数据库）

### 1.1 架构特征
- **数据库数量**：1 个（`community_group_buy`）
- **表数量**：19 张表
- **外键约束**：所有表间关联都使用**物理外键**（FOREIGN KEY）
- **部署特点**：所有微服务共享同一个数据库

### 1.2 原始表分布

```sql
community_group_buy 数据库（MySQL 8.0.36）
├── 社区域（2张）
│   ├── community                    -- 社区表
│   └── community_application        -- 社区申请表
│
├── 用户域（4张）
│   ├── sys_user                     -- 用户表
│   ├── user_address                 -- 用户地址表
│   ├── user_account                 -- 用户账户表
│   └── user_feedback                -- 用户反馈表
│
├── 商品域（2张）
│   ├── product_category             -- 商品分类表
│   └── product                      -- 商品表
│
├── 拼团域（3张）
│   ├── group_buy                    -- 拼团活动表
│   ├── group_buy_team               -- 团实例表
│   └── group_buy_member             -- 参团记录表
│
├── 团长域（1张）
│   └── group_leader_store           -- 团长团点表
│
├── 订单域（3张）
│   ├── shopping_cart                -- 购物车表
│   ├── order_main                   -- 订单主表
│   └── order_item                   -- 订单项表
│
├── 配送域（1张）
│   └── delivery                     -- 配送单表
│
├── 支付域（2张）
│   ├── payment_record               -- 支付记录表
│   └── commission_record            -- 佣金记录表
│
└── 系统域（1张）
    └── sys_operation_log            -- 系统操作日志表
```

### 1.3 原始外键约束（跨域关联）

从 SQL 文件中可以看到以下**跨域外键**（这些在拆分后会受影响）：

| 约束名称 | 从表 | 字段 | 关联表 | 关联字段 | 跨域关系 |
|---------|------|------|--------|---------|---------|
| fk_user_community | sys_user | community_id | community | community_id | 用户域 → 社区域 |
| fk_app_applicant | community_application | applicant_id | sys_user | user_id | 社区域 → 用户域 |
| fk_app_auditor | community_application | auditor_id | sys_user | user_id | 社区域 → 用户域 |
| fk_app_community | community_application | approved_community_id | community | community_id | 社区域内部 |
| fk_address_user | user_address | user_id | sys_user | user_id | 用户域内部 |
| fk_account_user | user_account | user_id | sys_user | user_id | 用户域内部 |
| fk_feedback_user | user_feedback | user_id | sys_user | user_id | 用户域内部 |
| fk_product_category | product | category_id | product_category | category_id | 商品域内部 |
| fk_group_product | group_buy | product_id | product | product_id | 拼团域 → 商品域 ⚠️ |
| fk_team_activity | group_buy_team | activity_id | group_buy | activity_id | 拼团域内部 |
| fk_team_launcher | group_buy_team | launcher_id | sys_user | user_id | 拼团域 → 用户域 ⚠️ |
| fk_team_leader | group_buy_team | leader_id | sys_user | user_id | 拼团域 → 用户域 ⚠️ |
| fk_team_community | group_buy_team | community_id | community | community_id | 拼团域 → 社区域 ⚠️ |
| fk_member_team | group_buy_member | team_id | group_buy_team | team_id | 拼团域内部 |
| fk_member_user | group_buy_member | user_id | sys_user | user_id | 拼团域 → 用户域 ⚠️ |
| fk_member_order | group_buy_member | order_id | order_main | order_id | 拼团域 → 订单域 ⚠️ |
| fk_store_leader | group_leader_store | leader_id | sys_user | user_id | 团长域 → 用户域 ⚠️ |
| fk_store_community | group_leader_store | community_id | community | community_id | 团长域 → 社区域 ⚠️ |
| fk_cart_user | shopping_cart | user_id | sys_user | user_id | 订单域 → 用户域 ⚠️ |
| fk_cart_product | shopping_cart | product_id | product | product_id | 订单域 → 商品域 ⚠️ |
| fk_cart_activity | shopping_cart | activity_id | group_buy | activity_id | 订单域 → 拼团域 ⚠️ |
| fk_order_user | order_main | user_id | sys_user | user_id | 订单域 → 用户域 ⚠️ |
| fk_order_leader | order_main | leader_id | sys_user | user_id | 订单域 → 用户域 ⚠️ |
| fk_order_address | order_main | receive_address_id | user_address | address_id | 订单域 → 用户域 ⚠️ |
| fk_order_delivery | order_main | delivery_id | delivery | delivery_id | 订单域 → 配送域 ⚠️ |
| fk_item_order | order_item | order_id | order_main | order_id | 订单域内部 |
| fk_item_product | order_item | product_id | product | product_id | 订单域 → 商品域 ⚠️ |
| fk_item_activity | order_item | activity_id | group_buy | activity_id | 订单域 → 拼团域 ⚠️ |
| fk_delivery_leader | delivery | leader_id | sys_user | user_id | 配送域 → 用户域 ⚠️ |
| fk_payment_user | payment_record | user_id | sys_user | user_id | 支付域 → 用户域 ⚠️ |
| fk_payment_order | payment_record | order_id | order_main | order_id | 支付域 → 订单域 ⚠️ |
| fk_commission_leader | commission_record | leader_id | sys_user | user_id | 支付域 → 用户域 ⚠️ |
| fk_commission_order | commission_record | order_id | order_main | order_id | 支付域 → 订单域 ⚠️ |
| fk_log_user | sys_operation_log | user_id | sys_user | user_id | 系统域 → 用户域 ⚠️ |

**⚠️ 标记的 22 个外键**：跨域外键，拆分后需要删除物理约束！

---

## 二、拆分后架构（微服务数据库）

### 2.1 架构特征
- **数据库数量**：**7 个独立数据库**
- **表数量**：19 张表（不变）
- **外键约束**：
  - ✅ **单库内关联**：保留物理外键（11个外键）
  - ❌ **跨库关联**：删除物理外键，改为应用层校验（22个外键）
- **部署特点**：每个微服务独立数据库，服务隔离

### 2.2 拆分后表分布

```
┌─────────────────────────────────────────────────────────┐
│  user_service_db（用户服务数据库）                        │
│  ├── sys_user                    -- 用户表               │
│  ├── user_address                -- 用户地址表           │
│  ├── user_account                -- 用户账户表           │
│  ├── user_feedback               -- 用户反馈表           │
│  └── sys_operation_log           -- 系统操作日志表        │
│  【5张表】                                                │
│  保留外键: fk_address_user, fk_account_user,            │
│           fk_feedback_user, fk_log_user                 │
│  删除外键: fk_user_community（跨库）                      │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  product_service_db（商品服务数据库）                     │
│  ├── product_category            -- 商品分类表           │
│  └── product                     -- 商品表               │
│  【2张表】                                                │
│  保留外键: fk_product_category                          │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  groupbuy_service_db（拼团服务数据库）                    │
│  ├── group_buy                   -- 拼团活动表           │
│  ├── group_buy_team              -- 团实例表             │
│  └── group_buy_member            -- 参团记录表           │
│  【3张表】                                                │
│  保留外键: fk_team_activity, fk_member_team             │
│  删除外键: fk_group_product, fk_team_launcher,          │
│           fk_team_leader, fk_team_community,            │
│           fk_member_user, fk_member_order（6个跨库）     │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  order_service_db（订单服务数据库）                       │
│  ├── shopping_cart               -- 购物车表             │
│  ├── order_main                  -- 订单主表             │
│  └── order_item                  -- 订单项表             │
│  【3张表】                                                │
│  保留外键: fk_item_order                                │
│  删除外键: fk_cart_user, fk_cart_product,               │
│           fk_cart_activity, fk_order_user,              │
│           fk_order_leader, fk_order_address,            │
│           fk_order_delivery, fk_item_product,           │
│           fk_item_activity（9个跨库）                     │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  payment_service_db（支付服务数据库）                     │
│  └── payment_record              -- 支付记录表           │
│  【1张表】                                                │
│  删除外键: fk_payment_user, fk_payment_order（2个跨库）  │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  delivery_service_db（配送服务数据库）                    │
│  └── delivery                    -- 配送单表             │
│  【1张表】                                                │
│  删除外键: fk_delivery_leader（1个跨库）                 │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  leader_service_db（团长服务数据库）                      │
│  ├── group_leader_store          -- 团长团点表           │
│  ├── commission_record           -- 佣金记录表           │
│  ├── community                   -- 社区表               │
│  └── community_application       -- 社区申请表           │
│  【4张表】                                                │
│  保留外键: fk_store_community, fk_app_community         │
│  删除外键: fk_store_leader, fk_commission_leader,       │
│           fk_commission_order, fk_app_applicant,        │
│           fk_app_auditor（5个跨库）                       │
└─────────────────────────────────────────────────────────┘
```

---

## 三、核心变化详解

### 3.1 物理外键变化

#### ✅ 保留的物理外键（11个）

| 数据库 | 约束名称 | 说明 | 理由 |
|--------|---------|------|------|
| user_service_db | fk_address_user | user_address → sys_user | 同库强一致性保证 |
| user_service_db | fk_account_user | user_account → sys_user | 同库强一致性保证 |
| user_service_db | fk_feedback_user | user_feedback → sys_user | 同库强一致性保证 |
| user_service_db | fk_log_user | sys_operation_log → sys_user | 同库弱一致性（ON DELETE SET NULL） |
| product_service_db | fk_product_category | product → product_category | 同库强一致性保证 |
| groupbuy_service_db | fk_team_activity | group_buy_team → group_buy | 同库强一致性保证 |
| groupbuy_service_db | fk_member_team | group_buy_member → group_buy_team | 同库强一致性保证（级联删除） |
| order_service_db | fk_item_order | order_item → order_main | 同库强一致性保证（级联删除） |
| leader_service_db | fk_store_community | group_leader_store → community | 同库弱一致性（ON DELETE SET NULL） |
| leader_service_db | fk_app_community | community_application → community | 同库弱一致性（ON DELETE SET NULL） |
| leader_service_db | fk_app_applicant | community_application → sys_user | ❌ 错误！这是跨库外键，应该删除 |

**修正**：`fk_app_applicant` 和 `fk_app_auditor` 实际上是跨库外键（community_application 在 leader_service_db，sys_user 在 user_service_db），应该删除！

#### ❌ 删除的物理外键（22个）

所有跨数据库的外键都必须删除，改为**应用层校验**：

**拼团服务（6个）**：
- fk_group_product：group_buy → product（拼团域 → 商品域）
- fk_team_launcher：group_buy_team → sys_user（拼团域 → 用户域）
- fk_team_leader：group_buy_team → sys_user（拼团域 → 用户域）
- fk_team_community：group_buy_team → community（拼团域 → 团长域）
- fk_member_user：group_buy_member → sys_user（拼团域 → 用户域）
- fk_member_order：group_buy_member → order_main（拼团域 → 订单域）

**订单服务（9个）**：
- fk_cart_user：shopping_cart → sys_user
- fk_cart_product：shopping_cart → product
- fk_cart_activity：shopping_cart → group_buy
- fk_order_user：order_main → sys_user
- fk_order_leader：order_main → sys_user
- fk_order_address：order_main → user_address
- fk_order_delivery：order_main → delivery
- fk_item_product：order_item → product
- fk_item_activity：order_item → group_buy

**团长服务（4个）**：
- fk_store_leader：group_leader_store → sys_user
- fk_app_applicant：community_application → sys_user
- fk_app_auditor：community_application → sys_user
- fk_commission_leader：commission_record → sys_user

**支付服务（2个）**：
- fk_payment_user：payment_record → sys_user
- fk_payment_order：payment_record → order_main

**配送服务（1个）**：
- fk_delivery_leader：delivery → sys_user

**用户服务（1个）**：
- fk_user_community：sys_user → community

---

### 3.2 数据一致性保障策略变化

#### 拆分前（单体数据库）
```sql
-- 示例：订单关联用户，通过物理外键保证
CREATE TABLE `order_main` (
  `user_id` bigint NOT NULL,
  CONSTRAINT `fk_order_user` FOREIGN KEY (`user_id`) 
    REFERENCES `sys_user` (`user_id`) 
    ON DELETE RESTRICT ON UPDATE CASCADE
);
-- ✅ 优势：数据库层面强制约束，无法插入不存在的user_id
-- ❌ 劣势：紧耦合，无法独立扩展订单服务
```

#### 拆分后（微服务数据库）
```sql
-- 订单服务数据库：删除物理外键
CREATE TABLE `order_main` (
  `user_id` bigint NOT NULL COMMENT '下单用户ID',
  -- 无物理外键约束
);
```

```java
// 应用层校验（OrderService）
@Service
public class OrderServiceImpl {
    @Autowired
    private UserServiceClient userServiceClient; // Feign客户端
    
    public void createOrder(CreateOrderRequest request) {
        // 1. 调用用户服务校验用户存在性
        Result<UserDTO> userResult = userServiceClient.getUserById(request.getUserId());
        if (!userResult.isSuccess() || userResult.getData() == null) {
            throw new BusinessException("用户不存在");
        }
        
        // 2. 调用商品服务校验商品库存
        Result<ProductDTO> productResult = productServiceClient.getProduct(request.getProductId());
        if (!productResult.isSuccess() || productResult.getData().getStock() < request.getQuantity()) {
            throw new BusinessException("商品库存不足");
        }
        
        // 3. 创建订单（保存快照）
        OrderMain order = new OrderMain();
        order.setUserId(request.getUserId());
        order.setProductName(productResult.getData().getProductName()); // 快照
        orderRepository.save(order);
    }
}
```

**新增策略**：
1. **应用层校验**：通过 HTTP REST API 调用其他服务验证数据有效性
2. **数据冗余（快照设计）**：order_item 表保存商品名称、价格等快照，避免频繁跨服务查询
3. **最终一致性**：通过消息队列（RabbitMQ）或 Saga 模式保证分布式事务
4. **补偿机制**：操作失败时通过逆向操作回滚（如退款、库存回退）

---

### 3.3 查询逻辑变化

#### 场景1：查询订单详情（需要商品名称）

**拆分前（单表JOIN）**：
```sql
SELECT 
  o.order_id, o.order_sn, o.total_amount,
  oi.product_name, oi.price, oi.quantity,
  p.cover_img, p.detail  -- 实时查询商品表
FROM order_main o
JOIN order_item oi ON o.order_id = oi.order_id
JOIN product p ON oi.product_id = p.product_id
WHERE o.user_id = 1;
```
- ✅ 优势：单次查询获取所有数据
- ❌ 劣势：跨域表JOIN性能差，商品表锁影响订单查询

**拆分后（快照 + API调用）**：
```sql
-- 订单服务内部查询（已有快照）
SELECT 
  o.order_id, o.order_sn, o.total_amount,
  oi.product_name, oi.product_img, oi.price, oi.quantity  -- 快照数据
FROM order_main o
JOIN order_item oi ON o.order_id = oi.order_id
WHERE o.user_id = 1;
-- ✅ 无需跨库查询，性能极高
```

```java
// 如果需要商品实时详情（如审核订单时）
ProductDTO product = productServiceClient.getProduct(orderItem.getProductId());
// ✅ 通过HTTP调用商品服务，服务解耦
```

#### 场景2：查询用户所在社区名称

**拆分前**：
```sql
SELECT u.username, c.community_name
FROM sys_user u
JOIN community c ON u.community_id = c.community_id
WHERE u.user_id = 1;
```

**拆分后**：
```java
// 1. 查询用户
UserEntity user = userRepository.findById(1L);

// 2. 调用团长服务查询社区
CommunityDTO community = leaderServiceClient.getCommunity(user.getCommunityId());

// 3. 组装结果
UserWithCommunityVO vo = new UserWithCommunityVO();
vo.setUsername(user.getUsername());
vo.setCommunityName(community.getCommunityName());
```

---

### 3.4 分布式事务处理

#### 示例：用户参团支付流程

**拆分前（本地事务）**：
```java
@Transactional
public void joinGroupBuy(Long userId, Long teamId) {
    // 1. 扣减余额
    userAccountRepository.deductBalance(userId, amount);
    
    // 2. 创建订单
    Order order = orderRepository.save(newOrder);
    
    // 3. 添加参团记录
    groupBuyMemberRepository.save(member);
    
    // 4. 更新团人数
    groupBuyTeamRepository.incrementMemberCount(teamId);
    
    // ✅ 任一步骤失败，整体回滚
}
```

**拆分后（Saga模式 + 补偿）**：
```java
public void joinGroupBuy(Long userId, Long teamId) {
    String sagaId = UUID.randomUUID().toString();
    
    try {
        // Step 1: 调用用户服务扣减余额
        userServiceClient.deductBalance(userId, amount, sagaId);
        
        // Step 2: 调用订单服务创建订单
        Order order = orderServiceClient.createOrder(orderDTO, sagaId);
        
        // Step 3: 本地服务添加参团记录
        groupBuyMemberRepository.save(member);
        
        // Step 4: 更新团人数
        groupBuyTeamRepository.incrementMemberCount(teamId);
        
    } catch (Exception e) {
        // 补偿操作（按逆序回滚）
        compensationService.rollback(sagaId);
        // - 返还用户余额
        // - 取消订单
        // - 删除参团记录
        throw new BusinessException("参团失败", e);
    }
}
```

**补偿表设计**（每个服务新增）：
```sql
CREATE TABLE saga_compensation_log (
  saga_id VARCHAR(50) PRIMARY KEY,
  service_name VARCHAR(50),
  action VARCHAR(50),
  compensation_data TEXT,  -- JSON格式，用于回滚
  status TINYINT,          -- 0-待补偿/1-已补偿
  create_time DATETIME
);
```

---

## 四、拆分后的配置变化

### 4.1 数据库连接配置

#### 拆分前（application.yml）
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/community_group_buy
    username: root
    password: 123456
```

#### 拆分后（每个服务独立配置）

**UserService/src/main/resources/application.yml**：
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/user_service_db
    username: root
    password: 123456
```

**ProductService/src/main/resources/application.yml**：
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/product_service_db
    username: root
    password: 123456
```

**（其他5个服务类似）**

### 4.2 建库SQL脚本拆分

拆分后需要创建 **7 个独立的 SQL 脚本**：

```
community-group-buy-backend/sql/
├── 01_user_service_db.sql           -- 5张表
├── 02_product_service_db.sql        -- 2张表
├── 03_groupbuy_service_db.sql       -- 3张表
├── 04_order_service_db.sql          -- 3张表
├── 05_payment_service_db.sql        -- 1张表
├── 06_delivery_service_db.sql       -- 1张表
└── 07_leader_service_db.sql         -- 4张表
```

---

## 五、拆分的优势与挑战

### 5.1 优势（为什么要拆分）

| 优势 | 说明 | 示例 |
|------|------|------|
| **独立部署** | 每个服务独立升级、回滚 | 订单服务升级不影响商品服务 |
| **故障隔离** | 单个数据库宕机不影响其他服务 | 支付数据库故障，用户仍可浏览商品 |
| **性能优化** | 针对性调优单个数据库 | 订单表建立时间分区，不影响商品表 |
| **技术异构** | 不同服务可使用不同数据库 | 日志服务使用MongoDB，订单使用MySQL |
| **团队协作** | 不同团队独立开发，减少冲突 | 订单团队不需要关心商品表结构 |
| **水平扩展** | 高负载服务独立扩容 | 订单数据库单独读写分离、分库分表 |

### 5.2 挑战（需要解决的问题）

| 挑战 | 原因 | 解决方案 |
|------|------|---------|
| **数据一致性** | 无法使用数据库事务 | Saga模式、TCC、消息队列 |
| **查询复杂度** | 无法跨库JOIN | 数据冗余（快照）、API聚合查询 |
| **外键约束失效** | 跨库无法设置物理外键 | 应用层校验、定期数据修复脚本 |
| **网络开销** | 服务间调用增加延迟 | 缓存（Redis）、异步调用 |
| **调试困难** | 分布式事务难以追踪 | 链路追踪（SkyWalking）、统一日志（ELK） |
| **测试复杂** | 需要启动多个服务 | Docker Compose、集成测试框架 |

---

## 六、迁移步骤建议

### 6.1 渐进式迁移策略

**阶段1：保持单体数据库，按模块拆分服务**
- 7个微服务共享 `community_group_buy` 数据库
- 验证服务间API调用逻辑正确性
- 保留所有物理外键

**阶段2：创建独立数据库，双写过渡**
- 创建7个独立数据库，复制表结构
- 应用层同时写入旧库和新库
- 新库只读，验证数据一致性

**阶段3：切换读流量到新库**
- 逐步将查询请求迁移到新库
- 监控性能和错误率
- 保持双写，旧库作为备份

**阶段4：完全迁移，删除旧库**
- 停止双写，仅写入新库
- 删除跨库物理外键
- 下线旧的 `community_group_buy` 数据库

### 6.2 数据迁移脚本示例

```sql
-- Step 1: 从旧库迁移用户域数据到 user_service_db
INSERT INTO user_service_db.sys_user 
SELECT * FROM community_group_buy.sys_user;

INSERT INTO user_service_db.user_address 
SELECT * FROM community_group_buy.user_address;

-- Step 2: 删除跨库外键（在新库中）
ALTER TABLE user_service_db.sys_user 
DROP FOREIGN KEY fk_user_community;

-- Step 3: 验证数据一致性
SELECT COUNT(*) FROM user_service_db.sys_user;
SELECT COUNT(*) FROM community_group_buy.sys_user;
-- 确保两者数量一致
```

---

## 七、总结

### 核心变化概览

| 维度 | 拆分前 | 拆分后 | 变化 |
|------|--------|--------|------|
| 数据库数量 | 1个 | 7个 | ⬆️ +600% |
| 表数量 | 19张 | 19张 | ➡️ 不变 |
| 物理外键 | 33个 | 11个 | ⬇️ -67% |
| 跨库外键 | 0个 | 22个改为应用层校验 | ⚠️ 需要代码实现 |
| 数据一致性 | ACID（强一致） | BASE（最终一致） | ⚠️ 架构变化 |
| 查询方式 | 单库JOIN | 快照 + API聚合 | ⚠️ 性能优化 |
| 事务处理 | 本地事务 | 分布式事务（Saga） | ⚠️ 复杂度增加 |
| 部署方式 | 单点部署 | 独立部署 | ✅ 灵活性提升 |
| 故障影响 | 全局影响 | 局部影响 | ✅ 容错性提升 |

### 拆分后需要新增的代码模块

1. **服务间调用客户端**（每个服务）：
   - UserServiceClient
   - ProductServiceClient
   - OrderServiceClient
   - 等...

2. **分布式事务协调器**：
   - SagaCoordinator
   - CompensationService

3. **数据一致性检查脚本**：
   - 定期校验跨库关联数据的有效性
   - 修复孤立数据（如删除已不存在的user_id的订单）

4. **链路追踪组件**：
   - TraceId传递
   - 日志聚合

**拆分是为了应对未来的高并发、高可用需求，但也引入了分布式系统的复杂性。建议根据项目实际情况（如用户规模、并发量）评估是否立即全面拆分，还是分阶段渐进式演进。**

